#ifndef __CCWRAP_ITERATOR_INCLUDED
#define __CCWRAP_ITERATOR_INCLUDED

#include "../boost2std/boost2std_common.hpp"
#include <cstddef>

#include <algorithm>

#ifdef __CCWRAP_NATIVE_STL_HEADER_PATH
#include __CCWRAP_NATIVE_STL_HEADER_PATH(iterator)
#elif defined(__CCWRAP_HAS_INCLUDE_NEXT)
#include_next <iterator>
#else
#include <../include/iterator>
#endif

#if defined(__CCWRAP_NO_CXX11_ITERATOR) //|| defined(__CCWRAP_LESS_CXX11)
#include <boost/range/begin.hpp>
#include <boost/range/end.hpp>
#include <boost/next_prior.hpp>
namespace std {
    using ::boost::next;
    using ::boost::prev;
    using ::boost::begin;
    using ::boost::end;
}
#endif

#if defined(__CCWRAP_NO_HEADER_CXX14_ITERATOR)
#include <boost/range/cbegin.hpp>
#include <boost/range/cend.hpp>
#include <boost/range/rbegin.hpp>
#include <boost/range/rend.hpp>
namespace std {
    using ::boost::cbegin;
    using ::boost::cend;
    using ::boost::rbegin;
    using ::boost::rend;
    using ::boost::rcbegin;
    using ::boost::rcend;
}
#endif

#if defined(__CCWRAP_NO_HEADER_CXX17_ITERATOR)
namespace std {
    //using ::boost::data;
    //using ::boost::size;
    //using ::boost::empty;

    template <class C> constexpr typename C::pointer        data(C& c) { return &c[0]; }
    template <class A, size_t N> constexpr A*               data(A (&a)[N]) { return &a[0]; }
    template <class C> constexpr typename C::const_pointer  data(C const& c) { return &c[0]; }
    template <class A, size_t N> constexpr A const*         data(A const (&a)[N]) { return &a[0]; }

    template <class C          > constexpr size_t           size(C const& c) { return c.size(); }
    template <class A, size_t N> constexpr size_t           size(A const (&a)[N]) { return N; }

    template <class C          > constexpr bool             empty(C const& c) { return c.empty(); }
    template <class A, size_t N> constexpr bool             empty(A const (&a)[N]) { return N == 0; }
}
#endif

#if defined(__CCWRAP_LESS_CXX20)
namespace std {
   //using ::boost::ssize;
    template <class C          > constexpr ptrdiff_t        ssize(C const& c) { return ptrdiff_t(c.size()); }
    template <class A, size_t N> constexpr ptrdiff_t        ssize(A const (&a)[N]) { return ptrdiff_t(N); }
}
#endif


#endif  // __CCWRAP_ITERATOR_INCLUDED
