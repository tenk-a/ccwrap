#ifndef __CCWRAP_TYPE_TRAITS_INCLUDED
#define __CCWRAP_TYPE_TRAITS_INCLUDED

#include <cstddef>


#ifndef __CCWRAP_NO_HEADER_TYPE_TRAITS

#ifdef __CCWRAP_NATIVE_STL_HEADER_PATH
#include __CCWRAP_NATIVE_STL_HEADER_PATH(type_traits)
#elif defined(__CCWRAP_HAS_INCLUDE_NEXT)
#include_next <type_traits>
#else
#include <../include/type_traits>
#endif

#else

#if defined(_MSC_VER) && _MSC_VER >= 1400
# pragma warning(push)
# pragma warning(disable:4355)
#endif

#include <boost/type_traits.hpp>

#if defined(_MSC_VER) && _MSC_VER >= 1400
# pragma warning(pop)
#endif

namespace std {
    using ::boost::add_const;
    using ::boost::add_cv;
    using ::boost::add_lvalue_reference;
    using ::boost::add_pointer;
    using ::boost::add_reference;
    using ::boost::add_rvalue_reference;
    using ::boost::add_volatile;
    using ::boost::aligned_storage;
    using ::boost::alignment_of;
    using ::boost::common_type;
    using ::boost::conditional;
    using ::boost::copy_cv;
    using ::boost::decay;
    using ::boost::declval;
    using ::boost::extent;
    using ::boost::floating_point_promotion;
    using ::boost::function_traits;
    using ::boost::has_bit_and;
    using ::boost::has_bit_and_assign;
    using ::boost::has_bit_or;
    using ::boost::has_bit_or_assign;
    using ::boost::has_bit_xor;
    using ::boost::has_bit_xor_assign;
    using ::boost::has_complement;
    using ::boost::has_dereference;
    using ::boost::has_divides;
    using ::boost::has_divides_assign;
    using ::boost::has_equal_to;
    using ::boost::has_greater;
    using ::boost::has_greater_equal;
    using ::boost::has_left_shift;
    using ::boost::has_left_shift_assign;
    using ::boost::has_less;
    using ::boost::has_less_equal;
    using ::boost::has_logical_and;
    using ::boost::has_logical_not;
    using ::boost::has_logical_or;
    using ::boost::has_minus;
    using ::boost::has_minus_assign;
    using ::boost::has_modulus;
    using ::boost::has_modulus_assign;
    using ::boost::has_multiplies;
    using ::boost::has_multiplies_assign;
    using ::boost::has_negate;
    using ::boost::has_new_operator;
    using ::boost::has_not_equal_to;
    using ::boost::has_nothrow_assign;
    using ::boost::has_nothrow_constructor;
    using ::boost::has_nothrow_copy;
    using ::boost::has_nothrow_destructor;
    using ::boost::has_plus;
    using ::boost::has_plus_assign;
    using ::boost::has_post_decrement;
    using ::boost::has_post_increment;
    using ::boost::has_pre_decrement;
    using ::boost::has_pre_increment;
    using ::boost::has_right_shift;
    using ::boost::has_right_shift_assign;
    using ::boost::has_trivial_assign;
    using ::boost::has_trivial_constructor;
    using ::boost::has_trivial_copy;
    using ::boost::has_trivial_destructor;
    using ::boost::has_trivial_move_assign;
    using ::boost::has_trivial_move_constructor;
    using ::boost::has_unary_minus;
    using ::boost::has_unary_plus;
    using ::boost::has_virtual_destructor;
    using ::boost::integral_constant;
    using ::boost::is_abstract;
    using ::boost::is_arithmetic;
    using ::boost::is_array;
    using ::boost::is_assignable;
    using ::boost::is_base_and_derived;
    using ::boost::is_base_of;
    using ::boost::is_class;
    using ::boost::is_complex;
    using ::boost::is_compound;
    using ::boost::is_const;
    using ::boost::is_constructible;
    using ::boost::is_convertible;
    using ::boost::is_copy_assignable;
    using ::boost::is_copy_constructible;
    using ::boost::is_default_constructible;
    using ::boost::is_destructible;
    using ::boost::is_empty;
    using ::boost::is_enum;
    using ::boost::is_final;
    using ::boost::is_float;
    using ::boost::is_floating_point;
    using ::boost::is_function;
    using ::boost::is_fundamental;
    using ::boost::is_integral;
    using ::boost::is_lvalue_reference;
    using ::boost::is_member_function_pointer;
    using ::boost::is_member_object_pointer;
    using ::boost::is_member_pointer;
    using ::boost::is_nothrow_move_assignable;
    using ::boost::is_nothrow_move_constructible;
    using ::boost::is_object;
    using ::boost::is_pod;
    using ::boost::is_pointer;
    using ::boost::is_polymorphic;
    using ::boost::is_reference;
    using ::boost::is_rvalue_reference;
    using ::boost::is_same;
    using ::boost::is_scalar;
    using ::boost::is_signed;
    using ::boost::is_stateless;
    using ::boost::is_union;
    using ::boost::is_unsigned;
    using ::boost::is_virtual_base_of;
    using ::boost::is_void;
    using ::boost::is_volatile;
    using ::boost::make_signed;
    using ::boost::make_unsigned;
    using ::boost::make_void;
    using ::boost::rank;
    using ::boost::remove_all_extents;
    using ::boost::remove_bounds;
    using ::boost::remove_const;
    using ::boost::remove_cv;
    using ::boost::remove_cv_ref;
    using ::boost::remove_extent;
    using ::boost::remove_pointer;
    using ::boost::remove_reference;
    using ::boost::remove_volatile;
    using ::boost::type_identity;
    using ::boost::type_with_alignment;
}

#endif


#endif  // __CCWRAP_TYPE_TRAITS_INCLUDED
